import { NextRequest, NextResponse } from 'next/server';

// Types
interface ExecutionLog {
  id: string;
  timestamp: string;
  type: 'info' | 'success' | 'warning' | 'error';
  message: string;
  agent?: string;
  tokens?: number;
  cost?: number;
  executionId: string;
}

interface ExecutionSession {
  id: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  progress: number;
  startedAt: string;
  completedAt?: string;
  totalSteps: number;
  currentStep: number;
  agents: string[];
  tasks: string[];
  configuration: {
    processType: 'sequential' | 'hierarchical' | 'parallel';
    memory: boolean;
    collaboration: boolean;
    verbose: boolean;
    model: string;
    maxTokens: number;
  };
  metrics: {
    totalTokens: number;
    totalCost: number;
    apiCalls: number;
    duration: number;
  };
  output?: string;
}

// In-memory storage
let executionSessions: ExecutionSession[] = [];
let executionLogs: ExecutionLog[] = [];

// Simulation data for realistic execution
const simulationSteps = [
  { message: 'Initializing CrewAI execution engine...', type: 'info' as const, delay: 500 },
  { message: 'Loading agent configurations and tools', type: 'info' as const, delay: 700 },
  { message: 'Market Researcher: Starting Q4 market analysis', type: 'info' as const, agent: 'Market Researcher', delay: 800 },
  { message: 'Performing web searches for market data...', type: 'info' as const, delay: 900 },
  { message: 'Found 247 relevant market reports and articles', type: 'success' as const, tokens: 1250, cost: 0.15, delay: 1000 },
  { message: 'Content Strategist: Beginning content strategy development', type: 'info' as const, agent: 'Content Strategist', delay: 1200 },
  { message: 'Analyzing competitor content strategies...', type: 'info' as const, delay: 800 },
  { message: 'Generated content framework with 12 key themes', type: 'success' as const, tokens: 890, cost: 0.11, delay: 1100 },
  { message: 'Data Scientist: Processing customer behavior datasets', type: 'info' as const, agent: 'Data Scientist', delay: 1000 },
  { message: 'Running machine learning algorithms...', type: 'info' as const, delay: 1300 },
  { message: 'Model training completed with 94.2% accuracy', type: 'success' as const, tokens: 2100, cost: 0.28, delay: 900 },
  { message: 'Cross-agent collaboration: Sharing insights...', type: 'info' as const, delay: 600 },
  { message: 'Market Researcher: Integrating predictive analytics', type: 'info' as const, agent: 'Market Researcher', delay: 800 },
  { message: 'Content Strategist: Aligning content with market trends', type: 'info' as const, agent: 'Content Strategist', delay: 700 },
  { message: 'Generating comprehensive business intelligence report...', type: 'info' as const, delay: 1000 },
  { message: 'Report generation completed successfully!', type: 'success' as const, tokens: 3200, cost: 0.42, delay: 500 }
];

const outputChunks = [
  '\n# Executive Summary\n\nOur comprehensive Q4 analysis reveals significant opportunities in the emerging AI-driven SaaS market...',
  '\n\n## Market Dynamics\n\n• **Market Size**: The global SaaS market is projected to reach $720B by 2028\n• **Growth Rate**: 18.7% CAGR driven by digital transformation\n• **Key Drivers**: Remote work adoption, cloud migration, AI integration',
  '\n\n## Competitive Landscape\n\n### Leading Players\n1. **Salesforce** - Market leader with 19.8% share\n2. **Microsoft** - Strong growth in productivity suite\n3. **Adobe** - Creative cloud dominance\n4. **ServiceNow** - Enterprise workflow leader',
  '\n\n## Customer Insights\n\n**Churn Risk Analysis:**\n• 23% of customers show early warning signs\n• Primary factors: Poor onboarding (34%), Lack of feature adoption (28%)\n• Recommended interventions: Enhanced support, Feature education',
  '\n\n## Content Strategy Recommendations\n\n### Q1 2025 Content Themes\n1. **AI-Powered Workflows** - 15 pieces\n2. **Digital Transformation Stories** - 12 pieces\n3. **ROI Case Studies** - 8 pieces\n4. **Product Deep Dives** - 10 pieces',
  '\n\n## Strategic Recommendations\n\n### Immediate Actions (Next 30 Days)\n1. Launch AI feature beta program\n2. Implement proactive churn prevention\n3. Expand enterprise sales team\n4. Enhance onboarding experience',
  '\n\n### Medium-term Goals (Q1-Q2 2025)\n• Achieve 25% market share in mid-market segment\n• Reduce customer churn to <8%\n• Launch 3 new AI-powered features\n• Expand to 2 new geographic markets',
  '\n\n## Financial Projections\n\n**Revenue Forecast:**\n• Q1 2025: $12.4M (+22% YoY)\n• Q2 2025: $14.1M (+27% YoY)\n• Q3 2025: $15.8M (+31% YoY)\n• Q4 2025: $17.2M (+35% YoY)',
  '\n\n---\n\n*Report generated by CrewAI Advanced Analytics Team*\n*Confidence Level: 94.2% | Data Sources: 247 | Analysis Depth: Comprehensive*'
];

// POST /api/execution - Start new execution
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate required fields
    if (!body.agents || !Array.isArray(body.agents) || body.agents.length === 0) {
      return NextResponse.json(
        { success: false, error: 'At least one agent is required' },
        { status: 400 }
      );
    }
    
    if (!body.tasks || !Array.isArray(body.tasks) || body.tasks.length === 0) {
      return NextResponse.json(
        { success: false, error: 'At least one task is required' },
        { status: 400 }
      );
    }
    
    // Create new execution session
    const executionSession: ExecutionSession = {
      id: Date.now().toString(),
      status: 'pending',
      progress: 0,
      startedAt: new Date().toISOString(),
      totalSteps: simulationSteps.length,
      currentStep: 0,
      agents: body.agents,
      tasks: body.tasks,
      configuration: {
        processType: body.processType || 'sequential',
        memory: body.memory || true,
        collaboration: body.collaboration || true,
        verbose: body.verbose || true,
        model: body.model || 'Claude-3.5-Sonnet',
        maxTokens: body.maxTokens || 8192
      },
      metrics: {
        totalTokens: 0,
        totalCost: 0,
        apiCalls: 0,
        duration: 0
      }
    };
    
    // Add to storage
    executionSessions.push(executionSession);
    
    // Start execution simulation (in production, this would trigger real CrewAI)
    setTimeout(() => simulateExecution(executionSession.id), 100);
    
    return NextResponse.json({
      success: true,
      data: { 
        executionId: executionSession.id,
        session: executionSession
      },
      message: 'Execution started successfully'
    }, { status: 201 });
    
  } catch (error) {
    console.error('Error starting execution:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to start execution' },
      { status: 500 }
    );
  }
}

// GET /api/execution - Get execution status and logs
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const executionId = searchParams.get('id');
    const includeLogs = searchParams.get('logs') === 'true';
    
    if (!executionId) {
      // Return all execution sessions
      return NextResponse.json({
        success: true,
        data: {
          sessions: executionSessions,
          total: executionSessions.length,
          active: executionSessions.filter(s => s.status === 'running').length,
          completed: executionSessions.filter(s => s.status === 'completed').length
        }
      });
    }
    
    // Find specific execution session
    const session = executionSessions.find(s => s.id === executionId);
    if (!session) {
      return NextResponse.json(
        { success: false, error: 'Execution session not found' },
        { status: 404 }
      );
    }
    
    const responseData: any = { session };
    
    // Include logs if requested
    if (includeLogs) {
      responseData.logs = executionLogs.filter(log => log.executionId === executionId);
    }
    
    return NextResponse.json({
      success: true,
      data: responseData
    });
    
  } catch (error) {
    console.error('Error fetching execution:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch execution' },
      { status: 500 }
    );
  }
}

// PUT /api/execution - Update execution (pause, resume, stop)
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { executionId, action } = body;
    
    if (!executionId || !action) {
      return NextResponse.json(
        { success: false, error: 'ExecutionId and action are required' },
        { status: 400 }
      );
    }
    
    const sessionIndex = executionSessions.findIndex(s => s.id === executionId);
    if (sessionIndex === -1) {
      return NextResponse.json(
        { success: false, error: 'Execution session not found' },
        { status: 404 }
      );
    }
    
    const session = executionSessions[sessionIndex];
    
    switch (action) {
      case 'pause':
        if (session.status === 'running') {
          session.status = 'pending';
          addExecutionLog(executionId, {
            message: 'Execution paused by user',
            type: 'warning'
          });
        }
        break;
        
      case 'resume':
        if (session.status === 'pending') {
          session.status = 'running';
          addExecutionLog(executionId, {
            message: 'Execution resumed by user',
            type: 'info'
          });
        }
        break;
        
      case 'stop':
        if (session.status === 'running' || session.status === 'pending') {
          session.status = 'cancelled';
          session.completedAt = new Date().toISOString();
          addExecutionLog(executionId, {
            message: 'Execution stopped by user',
            type: 'warning'
          });
        }
        break;
        
      default:
        return NextResponse.json(
          { success: false, error: 'Invalid action' },
          { status: 400 }
        );
    }
    
    executionSessions[sessionIndex] = session;
    
    return NextResponse.json({
      success: true,
      data: { session },
      message: `Execution ${action}ed successfully`
    });
    
  } catch (error) {
    console.error('Error updating execution:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to update execution' },
      { status: 500 }
    );
  }
}

// DELETE /api/execution - Delete execution sessions
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const ids = searchParams.get('ids')?.split(',') || [];
    
    if (ids.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No execution IDs provided' },
        { status: 400 }
      );
    }
    
    const initialCount = executionSessions.length;
    executionSessions = executionSessions.filter(session => !ids.includes(session.id));
    
    // Also remove associated logs
    executionLogs = executionLogs.filter(log => !ids.includes(log.executionId));
    
    const deletedCount = initialCount - executionSessions.length;
    
    return NextResponse.json({
      success: true,
      data: { deletedCount },
      message: `Deleted ${deletedCount} execution sessions`
    });
    
  } catch (error) {
    console.error('Error deleting executions:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to delete executions' },
      { status: 500 }
    );
  }
}

// Helper functions
function addExecutionLog(executionId: string, logData: {
  message: string;
  type: 'info' | 'success' | 'warning' | 'error';
  agent?: string;
  tokens?: number;
  cost?: number;
}) {
  const log: ExecutionLog = {
    id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
    timestamp: new Date().toISOString(),
    executionId,
    ...logData
  };
  
  executionLogs.push(log);
  return log;
}

async function simulateExecution(executionId: string) {
  const sessionIndex = executionSessions.findIndex(s => s.id === executionId);
  if (sessionIndex === -1) return;
  
  const session = executionSessions[sessionIndex];
  session.status = 'running';
  
  let currentOutput = '';
  let outputIndex = 0;
  let totalTokens = 0;
  let totalCost = 0;
  let apiCalls = 0;
  
  for (let i = 0; i < simulationSteps.length; i++) {
    // Check if execution was cancelled
    const currentSession = executionSessions.find(s => s.id === executionId);
    if (!currentSession || currentSession.status === 'cancelled') {
      return;
    }
    
    const step = simulationSteps[i];
    
    // Wait for step delay
    await new Promise(resolve => setTimeout(resolve, step.delay));
    
    // Add log entry
    const log = addExecutionLog(executionId, {
      message: step.message,
      type: step.type,
      agent: step.agent,
      tokens: step.tokens,
      cost: step.cost
    });
    
    // Update metrics
    if (step.tokens) {
      totalTokens += step.tokens;
      apiCalls++;
    }
    if (step.cost) {
      totalCost += step.cost;
    }
    
    // Add output chunk
    if (outputIndex < outputChunks.length && i > 4) {
      currentOutput += outputChunks[outputIndex];
      outputIndex++;
    }
    
    // Update session progress
    session.currentStep = i + 1;
    session.progress = ((i + 1) / simulationSteps.length) * 100;
    session.metrics = {
      totalTokens,
      totalCost: Math.round(totalCost * 100) / 100,
      apiCalls,
      duration: Date.now() - new Date(session.startedAt).getTime()
    };
    session.output = currentOutput;
    
    executionSessions[sessionIndex] = session;
  }
  
  // Mark as completed
  session.status = 'completed';
  session.completedAt = new Date().toISOString();
  session.progress = 100;
  session.metrics.duration = Date.now() - new Date(session.startedAt).getTime();
  
  addExecutionLog(executionId, {
    message: `Execution completed successfully in ${Math.round(session.metrics.duration / 1000)}s`,
    type: 'success'
  });
  
  executionSessions[sessionIndex] = session;
}